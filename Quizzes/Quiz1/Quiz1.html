<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf3a31004dc10a2ceefbde84db84fb97b742b1d3e915725c2eb8717f7d0945a29721f6df59fcce2244a0d2ea3c40e641bddc0aedee38001e4ae5c61073e4092587a4a84741b7de46b8a67965a79e838d4865389b883346d4cc3ddf9fe83a762de14a4fa9367f134333bdabded7c6bcf0a7a0784154e18e708b4ee905d502cdff074d8080eb88d11a4de868548af158e2ca3518ce9c2121c83436eadb6eb889e28dc58c3406df7115063d32f1560442449b143975b01a01b0e4f13322ecf60eab0cd31a187cb93f661a6a2341422e000cc67fcdf51b01178fdb2e6f71b2f1bff62e14ede3d5b036533d29248a2b4699352873652e34232d23210ff026df07ba08f04e94788871a937ad2f1fd2ffedd95b7af78191836cebb4af3084b71d9f5ded570fae7d7c42a94f8ff8ae678a9b8d8497795ad4a875784ec407796e825101f288ad7a6a1bec68b0eedd31179c16f8045469cc30c3cd7e630c8daa9f677d16e6c75303105dd7f462e78a321c9f53190d027b492159d0d638a420e0aa2577b4a8e20e52d015d3af526fe8ec4bc303875372ae1e68551127e6976c4033f2647cf7eab4b3440120ecfe26872e5430ece123576534e47b110d9739d52826d514f2228375d020ab9fb161b1f203ff342e03fc916e27101865546286c78fe1122f9ff692daf1e0fcb4a8cd3148b505c5060551bd8352c13999fd8720b8c04b181305a9d7c6c7461c495e12785aa9ef7b07af040382d99209bb7b8c523f4d685519426dff9a9509ce1788124d34066a518a30c14674851cd343a6d431911bbdc91ddf42d3bea9987789148551dcf2e6cc18b503e6747c87320ce4020db88c22d197a84d758552362f85c84636658f442a79bdedccd1f564673279b9923dd344b4da7014437692c9fd77068e8c226362dfd4ac30fbeb598f20d25c716ad5795ba8d113f695e8197bb9696c76a2f20f04fa079830ec5199d980bb0ad32ef5b7ae942e265db53d91bc8a236642ba450f8a5532ac3b385a1d2db5bee90a392b7f651f5801ff5659cfe000361c7ddfe13e8b176ff0326c20bcfd0d8d7c960e4cd24ac48481b7783993960948c06cedb62daeefda8d86520b959aecdecef03fb0633d1788b5b0d6d5cffc1183db513e15301aff43e4dad7fa656d4c5b03c9f75780d3ea3b490b88a80ca1a4329f1788c8c8f7d2511bfbf451c8e04f603f315bd0357b0c6776c09e7a7fae0e8b74188616349dfae276e1dc2bb796f8f10292c5397a2dead1195c81d2ff6ea6f40b58408abbd29b2ba240cd4aebbfda1286315e332c9faf2ef2aa4d6b2038cf3ca40ef073353f6b39cda06a78930d68b63266cae7080f19d744a8988ce996d3e42333f5d1539d33ba98bd2e1983801159cb12dfa173d6e7126824c007a5da4261dea85c88eba904ff7b21c1a28fcae33153faeee9fc8f313a819740931a98b9ab772b7507bb45cdbaccce72dbc173b92f2e541d84a17fbe4cc2dc2995098cbffef929169656a7abad1b3865d4653ecba8c8b95f251d23404fd063a617d40b150bf24f5937b8cac6ddc791900c27b7a8de9437fbf6c99cc5472b34874bc2179126d9bf7e74b096e0592f195125fba65c7dc94135a9c32102af8d8d088ddd74c3d982d48c6675d0a07562a1d91e9b91e9d0706ece7d1b51f23b8c509ae54c217ab29fa18ffd7212fa2454eca6ddc136d9e5d075e0deea6493bd6a0aa44970190d0604ef1c7b1b9e28ca48863027556692b7f5abc124d30e0e102ef6043ddce3832e36f8923abc924eb86de39f70c8028c943df15265a826c67ae345e20fb48bc9adfbc9aeaecee73821a8fa4331cf96a57b27bb0eeb2650fc218762366f4eabad82db7cc79a630908b39756f3e4011eebd2a9e390650182f70ea217c10760c6d9eefd7afda00ca514bbeb84b6f893338bd7aa2273cd2692eb989a125c8e5e3b1d49ca7ae8aadb74efe24c92bb6f6dad58f201aa10adb0eb30351e773636690f5c281e8314348ca2308d0abd7d2082e25ed79072ee1b528e693a9d67c904af64b0ffbca4b1c4ea8c98ab4c565eeecef14bc244f65cd682ad3226e9cdaae980c488b3a115a657df06b7ba1af528d6d3b61fd8179a06e214a5652990559c2bcf5b2204cd93a3452d76d7438fc503aa8a472a65726fbca161697b06e529f3b0d5b1c5aba0a8dff463520ddb43efe66170e804140e8502b9b36eee6641ddfccd7d11d4b6d267beae57bb7bac73c7532d94addfc9c874b3a9d4391050e5345b3d560ecc78a23799a8a8884ba6711f8ed6ae2d36e15f2526b26e0d15659814e63a645bbf817b69c89416178f4f7ccba0bf3bf91efddc9469426129dd59d75f5d6a909424c561b5f920f3f46acef04a259fc69c5ecdb3fa93fdcdbf8b87ebbc051de74a5e246da3f974b517364f2a90186204e4a5fae2842ce1568dbe912083c547584d2b12cfc96b79ef211f865301040aa28c53cb66f230d83ecf5f868c638102ba9be45664f5db2a0a4ef9382963b090ef040339d1a44e9db3ac75ca9df4855d8e96a4642b577e687aabd11b6470dd492600dd2ef0dcd115ecc948a88fabd0ce24291ef5334ee5c90ad7ae97c64861999d49b29ef59bdb4f1bd9a955178f7c6eed9742c44a98db8d64cbe8ffbbfb43cdf6036b88afa738e099c0498811c04c7706a21bf9a7c24e78170614178f30520ff0226da179aecd4c09c6864cbc1997382534d3bb738ed5a1b3704bc44fd3ed46cbe57ad0f2e117c1ba753e496a4451976a853c21986a15bd7eaa884205719a7a9bb1f93c8b29e4544657a61a31a9ba55d494584d7a7edb4dc440c45de93d17d2248ed1e5f89d055e9cfef6e6a90cf621f1b9d8c2e3f60ed2fff2100a54c27d2ccfd8de2e05d35f67d518e138d698922d42f895ddeb3fbf89a2174b3958ff9ca12c2c2b0dc7a7571df4a68d4a48ece439353377638bc7b105ae2bb4a27e15c2d3a1f53d91a80fa540687d93cbce465b4d931983fabe3fd9cc6ac1b5d8d12ba9198c88c2c93bd51c553a036378f6c36166db9898f242275601d5135f402edcdf44f4565bc2c9f59a87550115c224f405ca5f2561262a3bae41e341d6f6f595665bc79a57ce5192eaf0c60e8dee3c8f043a58a8252fdad4506ff076132ddf69d1c9231557be18213607931ff7166022b36da51db775037a1c5c8413cc370aa3b8f5d1c9ab756f4ca5ea09ec87b1afcea91c9cfc7c260cf76ca413dbb61da0054113e9105fc946e3ccf171f71f6e12172a279607236e14ac52e6de9884fe8dbefb535182dc30e63f33542054a11c07077266f3788d4723e17802188c1efb36ebefd1cebdc01307d287d8651c9adeb095c857aaa9754d95393bb8c0d36af40a150a20ce85f66a7b634955b828a33cc181091b80d00fc923b4714aafdeb9a34879dc81878fbbfc389f1ec934ee8c0f017740b98f767ac208f3528af9c300ddf787f97544e2729082a5512409ef49d2bca0163cb2f1fdbf9677b7604a87dc2afaca967ffa20cb3dcdfd71b4b55f608207cd98c873c0d4158a43abb538744619bea3a59aa9100b81ae9ff7fc963ac4288e59a40f379a9920685ca99fdc3598e645e1e2537065991d56620c48ade006dca215b49e975c68aa600b4f1915436e66f66d6cc0a7acd0bb8f3346ed19d76b364083810cf0dae31f580ab761a80f4ace4f8311385af550e43335f036d6d1800bc259bbae8664a0f33153fd32ca34f69c55a712b61c3bf18cce2f9efce06c7a6bec7a1645f48a5092d451350fab6280b50b474dcdd8d59691397b6ad4e385b6db5ee7a3bde56328d390418a5af7a632b8663c81612e07b5741296b967d89208616e7692da94f14470a0ff31185e8ce64d8a7a8c8938d5df4e70ce6b2894468a24ee076ce1db7d22a996f51413ce22268e63f6955ccea4346713a997c6ee17435c3117156dcb70e87e7016385cebf51fa385bd97d0b6d1374df5b610fd8a4eea0411c57ce2aab7b4482a6d7ee00a797e3e44bf803bee0359103436843982f2f008a3ee74d997f2142831c7437244ebec505259d45265b04f76e00786bed31e824d5c456ec274cc41df4f2f6a797c077ebe37513497cc8d244c4b9596fbb6f40dfadad92b7121f9bf290260eb1de3e5a0f422122cf6a9e5bcf36c22f2d99edea24eece5a67bcca152a1cf7d64a80f30ac26fdc1eab5e31bc0d1206c200023305df72ca1199651fbc1625599ac35d777504ea2e187f2070b6a1d08b234043a22274a81cae78125e5e2fa0d53e5dfb86d03fc5efa68f4546767ac8be19dfcdf6d57ef5fa16167a327cd514d3c458f0cff67d9736a8ce8a7a5fc4989465049910ad216d7c8ffcfd25169d0c6a38c3521d5be4a802d7d5e45f8ee5f10d8265e9fdf8726b61c3c59543df2231d8f8b332239a5d3e1f6bc48362b64fbe4e82ce2d8753970fcf888e179ed94b1a01b7101befc286089af206401cf93c4d950a9ae967fca877b33f5d23e5a493d7328775a95b9842f429bf29ad339c0c4196557ef05cba756d15c590a3c6f5990ef2710eb2201e0cfa17b203925b43e35c1e4b294076d37cb9123c5306c9c320fe39e1f4a708dfdd4740275d5650bf4a7b4f14a10117889fd226dfbbe2b79f8da4c80a37f9eda15120b404846898855513d1085750ba7d3417551610a7358762557080aade516312b29a6fb33530b84c8efefcf2db0785b6099c36004ff8fab595fa551b1dd9a8256201eb53fdf9110437084cc871ec329f722903b62b668443e71a1722a5275360423b626b8d546d1238305d19a6ac8bb846240c9c203b864cb9fcb406ebc7cdc44d9992f31088aaffdd9072047ffc1d20703cc4d16d19ff46d9d9af802cae022944346fdfc525d71bc01ef63c7c64b6d99ab68e7e874ef8c9ac13c51c9cb552fb4f501d2bb09b39e7fa196ed9b56c1148c2bc931ad3c657f1d5e3326af5cdcd7065ae30d9220a778192010c55dcda9d7f6fbcaced715d4aca946f62091cd75c2a3b13906567d0938e45cc207c9eb15c19a4868e7fc6f861d252cfa37d5c9423e7cc55315fc26ca4ae5fc4472c33596802908d8c40334f7534093ad6c531dd0f08b19152280426779cd7ff0bf14c8a54772b1bbf45f610a1d033f68af2a02e7697ae02b7ba9f575a666693dcfc9faa02624a5a9181eaff26bb712ce96b4b06891555d16521bd9db8baf938792bc3204e38d76b8829525c02346454354f5dae480fde1363cf935d1b6a11c9e162f2d6bc1eeff6ea83e714b5aba879803fe9a29b0bfb54669e3cefb34518c5503f3095a5dab84a6f7829d1a330507a068f4e4ff83adc50a80573561f0559e1daf5edfc5332c58f0fe2f30414545f2ff0a33139c78ab0b7da336c65023dbee5e3b8687ac45083081a68b5f06312ea888cfe5d4adbe8daf2a99a58330d3501ec090d6dd362b34164f1fe6f810e01163761bf332a3320ef66d63104bf7d455ebbe44f75dafe9079ca74db98b2e93aab5eed5423ba02038d234ad6c7ce7bc2c2834ee4ef45bbdda45631b755e2d331a0ad72952f7fa69ded33484019f98fcf5167afce84a0ece9cffa1885edc4e38ae2fdd602b34277a738bf2001a6c4d25367ce0b0a6642ef5cc0b588ad5e10daefbce4199553649a3fe42c47d956ec0775313631a34b3dc5dff19acba8f6dc66c5ce9fa61e358db0209b943155a2d06510d224fce461fcae5273ff6e2bd677b2e00a8eed3511dec2767490383d850306783dd765405173e136eba797d839059c6dc8e095c4ac569daba8569f1db7f1a91e88f6cdd1e24525cc2cb1a7fc01059a917d7bb855ba6cfee51f81f19b5880403a92a4da588d02ae0b3e9228d61ccf91ffc2bd24215845603197e3c5b809157fe148b4f66b2a020ba9ff3a3209e8f50ea18712174138d8c3838e4581aa45e534ac70c4c63beb034a701174ec482797b34da2f057f9edc5cf23638ed92e4f73dc85d3d2e8f7619fa198edfb82c93a00a5ef461d622dc26b3c339641cdef2dded7e624ba7f3df23771cfb93796f4fb2fdd83997011baddf495f92c84de18b77724c81b82da652a7534209669ceb07a174650cac24211817730f0aca046e85ead263cbde6d6a2fefa30d81e3005b7f812510ba748e2d341175c966dc943fc11aadd93e5094871c85df9e347f7e2c49361f3a534a9d1d76277acd084f8ce742f12375e22a9af30e02ec9dfff1cbd49370af3bcba413e2444fa08f9857345249cef71e15f12753fadaf2b1f69824b71d22f3e144b05c92824efb2bec0b772013ff825aa9298e3c94544bd5be0d94f68c0296faac413ee76203becd733d7f258ce991fc29d42f9f3e5b086613d8e234e6e49681e1210bd228d946b6a1af41b35653d90d5e53964c8a739de2e11d32459cd4c80f6cc2e7f21cfa54b4002e7ff8f898182ed7dd7fdfa856a1d09ecba0df86d58d4c22b5f529f313a2e2855a4f9d1928cf4143ed1b83593b7abda88f5fe770f12110318942ccb9bd7cde37859b2a3263e946e52a516a926446fcafa62886c23f72172901c2bbbce58afde46ff4c9c1646b77b9c69235299ff924a2f91e4668ade1cf9f0b3e41fb00be10769af7fc8f31ae95197f2de8930c111f325975a51d0c168dfd51652a2ca477b37d2208d97472fd8d5db50a67057b48065eee190c6c504a36f95eb3392f16b5277ddd8e50b3edb0093532ff3abe6bbf9e106ba3e32ecf666bbac92fdec352753c1eb521d1e4c344590cfe93f61ef1370370f304234f5bd0831009135000240d624757ad2c3c2f921f4d13597a90815d6d87a4952501575a516826484f529cd812363ca3b6d2f5ae1579bc2a6764a2f9efc6710218c806c396228d8698ea9257e09063e59a86f5cc08405617cf97cbbc3837b7c9ae21a0d0f7b18c72371337292ad567080a407cb82b52b62b50c42b7718083a291764c72c1136c2dd5c86bed5d1eff35f07934c4f29193852cf472bbea6da7d3d0f53a375854ae87955a122351d58b1a200fa353fc710ac1547be555c1046826e6708a8c65ef21efd94624363f842a335314fde10c29bfde9b2126ff3b789629effcdccd862b010b5e0f50e43abe34d04543c94b71b1945fbcbfd7a9d532757df1aecb217375f86ca44bdee01033adea8384ffe849ad5c8bca1d43d3e571a812f570d000e190736a8153597d67a27d8928671834923b38950f45252b8ae76fb60eb96096f18dce09a032fb3b62af1c0e7fcbcfecae2104b4b13f9c62c6708a1b9dbb53e430a7dacc730e9727f479c2bcb8b0938aed2fe77841bebcc54eb131491efb90aca0ea73ee9bd99d5c8b036c59e939db57977cc9225a9a7f0ab94ed09b97cb5c66736fe81b37f643f5866f60ca8a329bca4a97263af8252a77554f4b8e5eed4b8924f02d21801eae913088849b9c29c02ab695f439006ddf83d4b6aca2cca4096c97790f6d2e4dbfcec9f7e489724fdd107896d2495d871d8422944d44f9e30fa5ecfeff09fff3dba2ffd2363f6471795adaf894d7e8677b62c504d801b1f0f3f32ee0d383af2cd2f7ffddae419d3b3c37137d167757c52def95be86183ec0e5d64ca9f4453c865f9851f1cf9de81e031512a5a42edd605e816f3adc33eb8ddee48d2e1b0743985c1d906b808f86aae44404c85530f79c263197fc995cf968dbde357b6d94e162f466361437a6edfd9e600f1c975d63506299be7a0277ad96db2dc86714a8aec51c89c54ad3f70b42b19ad46e9e158afea58a1eb8d07ce5fd706f1721fac6fe4116b3aceb67b08bcb54998e43e5314b72f5f89830048a25caaf0492188b9a60328b5cf428933d31b9f44b0c52613b1d8ee655a3a473d89aa30b38b83f7f6be2c7f24ac4ad300d7e9362e3fdcb08e9a3af41fbe22d79d893211678b01aece201d796928cb9dc401162fccbc3628b6d645b3dfdf7122a672c85738fc10cdf2486a577f596751ea95859f09df9b69a3b4aaeaa92d91676375ef2e79aecd874df541827f960f0262114f5f144c2588537a88c278fda217e04bd09b9d76cf0ffa868ec7384bd6dc971761ab3c8e0a96328cdada4f4c9ec4f37bc421f67b1a1631dc07db34d606c5a51166e54c29a180a24518752027cdb8e47252d3ec9e4fc3d0326f06ebf0d289466f4ccebf76f488c2bb0c7adb04f245f1b51f91abbf64968c2ef21e7657356fc4b85b396b077ceb8da71122d4b37e446fe6e97d655cda8ca47d00508e46ea693a1c761e50c1a36df2cd9153664eaddb803047052a9a781f40cdf807f4948eeb48e669dc4102cf3bef891791f07f968cb2557ef745a24c357059ad201b1b29f09ff13b30eb1b1434c1cac71dd9f7ad6d96b6499890daf1a01a696649afe843803113aa023e50cb3fa885b2c50ab52380ea34f2b3272e6c990a5afb528e3c02003bb22a252cfc32897cbbb6b925a258eaf9978ee6b355a1399add97dca0645861508be0c39e1afa50e92001698ba3d21f006dd819c1f9bee2029447f4aa99d462a0669c98433402898b9e58ed21f26d5a710d26ab5a6dc03c9b0f928b1f47201009d785bc990399041cca62071afa8eeecf23f2a9e20623bf30b989b16878bf81ee20153f4281d04cfaf5428318987e245b6366a1412dca8c43f41e14fa799c923c1242206ab28acbd07225ddbe872c7dec1f723c7c8ce6fb2605d5d31315750d7d6a49d516418ff9ef8126ed7c236b589e1ac95a2e926d5849f159783711bc2935a5bb8e54aed2ab7268b32539bda79f981626c18f69aa61b89704f796e24ca48cf3b9d44c5ed999db6a5daf6c5c5bc5a588962bf0aad2de412f6389afa02a39f99ed9bcca100406d0ded42501e6907af7bf00666e77b6594bdb3f8b47e739225eb60cda111f782ed508dbda518c4843b3bcd9255b55c8b5ad812fe101db45cf6e0299c6babcb35cb0647750baa9c3ca9a1addd03398a233c7c1c16096b300d73aabb0727352cc311cf9cae9f52d4eb4c37081251246fc8bc6d559752e7a2b17d91f008423ac7fb68da4238b2497509bc43b97e1dc22e9314ff08069ab8ef8bb1bbd2671ddf3100624cada61dc71e329e54b7397286beb7f80483fe5cdf70c92d68f98faf2285c86bd9938fcbffb7b73647ffabec52f3112e1f4339fc2450d94fc2154487878bf584566b94c6dbbf816363c41b5131b3e599e98249cb52623f82800aacc3ccb817f7b4891dd51026f906fc8b8f2a15763b681cefcd002a5b88ecc604617677c145ef17100d6401ab45fd756bb984b5aab9d73cdb41dffded0a2bb826e3a872c890af9a1722310f0be495060e8e2f5a88ae9279daca25913197dd8f5d0d5759f02992035c4bac31530eefdbe0cc65230027e2275739862e18664639ce7328c69aa2d133e7a5b31d28f52a346c58434bb38fc9a7c26460d4256045f09b1c8003bebaf11c3ca46f9a1a6dbac85aad5104eb80689ba1878f236e1f6f2c5de87e07d10dbbc846c3ced74e8d1153897f6d84cb8057b7e69b41b4ae23f5d7fda9ba56c12e232c90e0040ac3c13f71df0dc90cfb9af92b8ecf657cd848e3add51d9bd7dcfc03130e4fc3f5112ceaea9b24396b9df847865e87aca1268b4aaa2df98102ac4c2fb66b4c85d5a6c035b7e9a70d309f67d1b8855fad3c2b52f5ec656d281d7710a84a24bee178be5258433eab9638ab4d97182db574b5e9fa5005d28613ea1264d4fa470e531a127e6cf3200cecefdb4b768fabb7c8e3ac8dc10a65afb0c05514f80ab92f0d7e01206e06aaaee96d474c0c30b38209e007a9c94cdc48f776058769e21d5b9a8935469914193aef35e990391e279d5190afdbd5e3f20df1305dee154b262cdd849585c44493ca3a7cbcd3b3b0f9517455ea03e9fade9bd4136a6d94cbbc61c68063d3754effd4fa80d835f01e09cfedf498a467be92263788fa398b643b7a8e7ebe0abd72a3a5fa9142c9c2d783f23daa7c5bfcf8c4a5a7702201b761d84d9e8579ac9128deaefd60462f7cd420423d37732869f74aa368118fd024c6366ff85a0b9a4a747f764d4fed62783a60bc20fd6da45fd77c6ba6878dcd76de70d8bdd348189c81964416310297b6da2a1fb73bbbb50c218c6d002e24b9e2394bc0c1bf54569bf8c14a293550768b5d3d50df04354d8229400cf6eb4f966b036f6ea4aba512782ed42058633de1f8f40588f17bf723766498b90cb8e661e187a7dbfd2e3c78267e0f9577776604b23512f96a7ac25043b84c7cd1251d840bd3e306202ce1fd0a2f39384accfb79c6d8c50874ad370269343e3384aa270e5d255fb6d881ff651d5361eaab26b255d36af54092ccf1b9c535f81c6428917308ea425909334c761b7c33efc1a33d8bd564b89dc7cf0e221fdcf5bd727102cff49c46542050f71e598b6f59abb729532d2617135dab450c145d53c1abf978dc36c8cac848adbdf21fbc0cd210771bb89feb6ccfd4ddbc042e3872f667ca847907cb84e6b5dee0deda89531d43b24925be07f81cc470ff035f3866aab6e4964bedfeffa1c3c83c5ae5dbc3ec38cc8e31f61daf75b9230bef59ca6dbd00988e84a41b93acc59acd388baf1ba7096e5d2176810a0f98ed3731c0fbeb63ec8bb49f3fdba7e25327c676185645aad297e408c5c2510a3d5d7c70aca332245b427ca20a92e582a345d57c384b4db37f256e4f6315ac1eda749684449ae06b7dac97313df288f443961fef8dc588b5a8d2c6ba87f8704e612092dc4fe01665a29a914b10403f67617f3b54a1749a075dfcb572abca9ce93c2d48234aec37f3f7451c3f7dd4935b019b4dff0c783","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cffbbc892d2913430572c48b7089cac0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

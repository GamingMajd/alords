<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Quiz 2</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Quiz 2</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e94f9e94ac8fc02c5dab8c9961b4225f5eb37d837a3f41ebc582d1a0661048c1754de493433473124ebdf7634753b9f8acef712c0be02d889a146d230fd039ab0317ac6fa3a48492d48662e559a3453a697cfdc17a3cf13ff1a49943038b5982119fc1527c4b1ad30ae572996211358aac7e5d1ef68ba49131e0a66b3b9277d84b68291fae3e08b4903617826ed4cb1d45d4447e9e22291a38e4f08c9debb318e56cb108714d247cd48d103ca2082e866ce626bc03e5c92557b0ce00ea672509d5d9be25468dcaaf66a9f9fdd70acecdfb6a78f0cc4715975859269ff4d43286088f5ee20071a9de6010c2193dfb6f86c9b49ef6c6762d78f8e83315f4071ddbd423e0f8669a09f65747e2a0c08eeae277f0af42932522293690d1a7d7e4e4e4e2fc8032ff0bbde6bb8ec9ec45590f531e3a67efad87f07752a41ef002edc5758b64942c39c155e77e4313c422aed9fa18a0968e5dc0a072da7df23b957cb7a053c66a237aa540a0e7c1aac271e59a2c1603af8d9b8533e814265cce0dbe1418b5957d06bd400c4f1faa0a712a282b0dc6f4471b9e525265f3a41e6ae578af29c3388aba3a7d4c6e42cdba061350398a890f99883ce654d1a6b0619ed71c7eb8c5889953348f88acce176c9103356813087c2bfcbad860a3f613cebcd67f60cc58b9f045caf128a920f954452c003906e0e9a26e6e50af086a21ac2236f792407804e4a6f38a7258bded471cfaf23bcb52452772c95f973c1d06aff8f3822e8e33f413c339d2ba421294f1ae19f8104f8fcc6c63b75afbf5e44df24366bfc2a4c4e683b8ce33ed38cb77d7548a9c1390e6b3656cd7a149b36deccbf78b55c5bb91c7c97ea7b237dd389b798e4a3b3af1cf2c84ea161a4562f41141275e43848842220448c1f2b5ba2feff4cde309fdd4c0d2031405c33a365c5185b2b2f0b7f8cd5b15c72415b66db572b4c100115d9899d9a39e82a8ff2eb8545cb29b0d4a10530fc02dc8118c011bdd84965df93239fbf69189d45e30d953824eff4101e09e63906324a99afb733ad3604cca353df72e588fdf78625d922acbb4a09cf347dc901fa08454da03a22d60f7cbd711f584efab636dd7efbc81a803dfa7c62a17c02832a7abec41b4e6d68106bdbbfbbb6d1951274298f4d42db4fd33a1cf0fd70ac68c65a3eda9fc1bcf5cc595a26af4fead5d7c6b2fa035b79dc91473dc06be7163ee58891d3a1d9e1a899561158d065ef186eaa53f8a15698700718df16f984da7b831fc98a50f57ba4a37816b2284547e634841dd2363037d250c878eebc2b5962cc6249f4b353aa5ba6094c6116b0223e006bfe2039b8aee4814f30c6858188458640cddd028ba2c95cb53f846e92496006922e7d2e70edfff8e5810db6700fd371a60b311452456cb81691953e9dedd839b119ce5a4ca59e0d4ad08ed33334e07bcfe498a9fd7a5ac76c752e911683b557cfd6c3862effc6dea0882f6826d137af6eec47de16db7ff38d8ed57b5ab6eaf20bc3ee60c5a5160747c477be37f1181b6342ddf521a7160f29fd168bece3ea80d3bec26f2b92d28488bc691e3928a755ccd1eca203f7e804879628cc3cd89ed93943a86387ea83170813d47938377c0deab3a6b12da43e906de7997d819bda864e1813e986dcef867d65cf8a3be89c7daad4786a9ed173d630eb536c4af4d9740d3d9c01fc62ebe1dee597502d396289c9f6956f069ffc3e0029cf3e18203f0a7744640ccf3ae63c0f4ca6d7bc87a40dc90ba41168e911eb80e6816ee022b7b93c4e5291a5099a573244caa5ac79b0a027c1dc4e622628aec29720a4269218e5879567f5f176624908e098d80298a6495321cdc696fc32b1f8aaccec6294fef84e372be3456da45e8a7acd4ebce4790829b1b0340994fbee94924107d0902886c63eb53f7f258dc040fed1936bf273954979503a011b645332579bf0822408c1a5c494fe474a3441b629b1076c3eeeb7e1e0380c705095e08d0e2c5e1544b29732c46bf179d8cbb0c6070fbb20537b1ef391ff7333f5d4c1e084e699fc741c685cc9d2ec4c1e586e37522e9595469f3e6c8928c4ca839f2ad90fe567d153054daa13b2a598cf1164a89098da6937866a1e75f1bacc249775f04d0d1e8d612f97238abb0a4a983d3d66124085a0e910125ddbea6005ef6761851d970e655381eaef0fc327cbb44c94031c6faea78c5fda6cbe46a28235d1616ca8d4671c00ee1857c7159f0a81479b37e21ade3b0900c6a5691d70ba8260ae8531887d8eadd5551c60f31c987b51a39897cec1bde0a4140e0f1e5440d65240bb0dc19a786fc487b74f86419dd29ca20e7faa7884638d8513506d020a300cf7a7ca37dc02049da8ecd69f2a981adc31840324af064bc14389bb7bd0e3bc80b4b83a11eb29823683f7ec62b545b91c3df93002bdb1a948e5ca0a73233cba11b65f5cccfee7332b9721ba9cdedcf0f7ce79d1de8b16652d284a32e67abded5204686a320ce34f408c594a1704cfc3c21aaea1f6c8bb8f5f6d1844bbeb03ad2061c799dd0e31722330fb27892743e83732a6ba24df15188896cb1a95922295900acc5624a530cc762cd4409aef3cfbb351f51060fc715a90aa17ecab6fe9819d2b4c73a305b24453fabe66be62ed71d525ccc5450b7342a37053aaace9bcdab7b60ec58dbaab3fd042546c898afa947b1aee2b882c9e3641c16c79aa2e457703955bb415fef3cf07d2f58f11e4ed486431cfe0341467083eb27d8292a972139e7b906ce9f7c29bab9c96614fc35dfd456118abe31f36a4ad8692066eaa96f3c86ed902cf566f9f0db6f5d200b576192be43aa78b72a402e6575ac90c45ba807f4ccd5e75f14b23f93a4098d721805d82ae626d786d9b885c1ed3245ac7127bf3b893e7927028f963fbbc38a8bf43cadc87f31da9d68ef4b1fe91813d3a6df7a50a8725448c4e8355b88edbe35ca35411555ee3ed8e7ce3a343d3687cc1682b465817de30976e061fe2fd9b7eb36cc5ae03648e4ef9d49787f20d429a36a555d3ccf8550e4e045997b156c025e46ede149e7cedf48e95f97cdedfa739bab55517c88e15ca3ae1701643a0ad0e6a04f57ef26d089d114064f9441d4690f6ae91e521e65d1187b8793eaa47839a5fd9c167107ca9a88bcd5e8ecd71066fb2d87dd1407163b41f80c37749b84ea4cb441edda48c315e22d9f2638c089cab3406422907debb38006674005a667c32cb414f1da25e797282ca68f277a0e869f9c68c70f6dbd52de1d4bbbb9a3252948430b9a9efb73bd66861a43bf35537a3483fc7c6cd868f0c800f28fe45fef50347b168c9af58d8f9ce1ac048f7bed2b7f25ace62542981a2e3d87b5c7fe2b4bf38b2df1f9f486e5e3428c457c33061a40dcc6f0e870c4bdc8fe6c0eb606498a7da459e6020e0a5e34d379fd02751ccf6d63371f5b4cf521a6889ae2c64c1b0118afa2a51a6ded1a402e0678c6c47ba14ce6e523933629670b3ea53736581a8d52322d2d99f1534bfd4843d0abef5ba70f772a290fa3dc0383158cca2d1b5753e4916e054416c5492c79380505d032534455e57d9635792c1e6379509f8c2913b8621ce1b76fb0d675f0ab31d6351bef272a7b8992716ce464d118db6e7f495e4e145b33918d8eb3bcfe46247f1f84d34ea460d48556de968d4e31c1e8fceeff1465c60dd09e53dfe366515eea22007ab5757a1afceeb1b5fc493e4ec22d19b0a34d03ebafbfa0e87ec8279295195758c2e9df84b85d39f9f8424c702b9c5e901e7736597b61cefcbbff1f4164f25a5a3af090e5a15f53e521ba342bb3e877c7d1bf1740f68d210549cb4a5857b13179225e7207e768e5662ea4ef2231a72104873d11d4286e22a23bcce7b3d54097a6b00afae338c588d84c4b9beda8e90f1b070327c049e7be6873f652f2262c12e3faf98c2eebb811e7c14b6bb95619d61f15a2069e14c0c299a1e59ee7585b162c54bd7b5f2b828acf82f326f6c850200500841a9ed77a3665066ff136084de92b3deb8ad98632493d74b2beb71e21823b3de49caebc221ba30204a16b1589fe7f0f7f6ddb55266a300f130e06b4de2286c289e6e5d4798101ea677f0387cfcc9e5a9ef3334237df53dccbdcfb9b811385fe414cc7f6348b13a82e06189b390363da0606e01b187199dbd1b50193d382b5ed87fade6bb5cdb137ce508b29b3b12da626588678d180fb17764d00d3592059800baf73d322ce5de7d33f6f21ae898d3e51f2cb1369f819c9ba241e7a26ff69b25331fa046a443185cb962d6417f4bb7da84b0d0f309748c8e41217e11f9c96e60e413dce6b1ef3e67e4b1d787eb3c264687a3e74d8839ee8c96a8a52d43367c435a2ba4f3dd3563279beec176cca45b3175f762c28528f57547337da2ccd2a29a8df39bfb4db6bcb3dd2d2e7dae657280e0ff54131ad4ab0de48c4ad702ec79da7ae8f619d31b3d1e14e6511f373df5fc69f19882827335a8526c5236aa0ca691144380ce7721df3be55885364a9b0b6f57037182f7dda3bb685c3715d6dd48b8334fde0a57f04cc272b43415e27e37f6e1cff392182bacaae7a7a66ee0c92bf341d80464e406e7a79a66828b1b701dfc2301259b5f33b8d1b0ce6cfc48e825bd89d83f5f4362a41d4cff6af60f846b0199e06d2afae186c5f6ee52eae32c3088d396d9fe72dccecd10d71d809a3837c90ed9512a4fa2201b7aa9b10caf940cf40a0136b378fcd455309f12c99f8f56b3d7b3a2b68f34ac7e222d0f8e3a93eb89f5842e7998a4df5dab50c58be1d0d773104bed3feb07b0561f99f6a2d49fd5849318e42c7ef0c7019e40b98f8a9d50ad59af496817b437c32c5e205525d31ebaa128cf9083e28fbdfa4f891f1cc28810e38a77ee4da4c19a3109b1ccdf2948b6652d97528ee14a8594bf8bef99a74ac0da61f176909c3ca588dc062b530806a5dd9a4bbc648eac4a2485699a4957df3a21a1788fbdd731fce76d861b3ac3111152c388100533d5954a0ba9fe2cc20da78aea831c8ea36f82df55f88dca9c1b872a2e4a17964eb5066b8ff1c64033862c5ce25ea0ce9e550bca2cdbcb6e36d42eea3b928bd127be3c63b8241fc72894b40a356e4c4b36e362278f6f4c3f048c1b3311c8ff1adf170a7a91f5d9926b556f4efd593f7ccb33894ac2c05d3a41fe4fce2fddf76492b459d0d9549f1c3ba0db85b1fcae7b8e865202cf0b40ef5642c25ecec432d462de537dae4e9bd169a2c2bde5703ed4958569e01933b160ee328f826a180656202991f1287df35d421633796525b596878afd3608645a518ea31ebc06eb6f66247f19d0dc0f37a34d6a91cac37f0d4f75c88ab46f77d87bd6143d440714a0fc9bfd5f0cca5e946cb678ee78a4197f233b53673df01f87ce4e146e078b6f4a504338c0ed3870894b09bfa4d8a10fc5226bb6f0718bb7f892ca7bfde8eb6eae4e39970628bcdc6f6dcf875c2bf0ce8655ab961f68d07a23541566ac658268e7929062b0a6b562df11d6736ebc1ed9282b23a597cf3a8312b2eaac6d3ab2ef7d1ea7ad38362787b50cec1ed9cd7897b74bdd5d09fe2414b8ed7d513b98c519d7e87d960629fa71f640a4517f9f301bc0982bf99e529165f29acf0223608c2c71edfa73727e1233dc309e295274a68fe731140e73e10a8e2648f57ef5fca97abf25e8cce2b4304122ea0e78da1aed7d871547f6dc59358b8b0e3f4c838c909b1dce15543531a7966786aebc818219dec38b74862af4581e8fa4786880e392da6e633985e2535682b45993b5fbd0faef1d6b86d2193c08f23b446730c6db9a17416400a455f43cb4110a50432b494726f4f639d9966225d1d9577dbf7b10b4786517338bf78877dc772ae16dadc27e15e6965b06ff9a49d8d5fac512d1608c603df7b764856d9f9daf2675b15134f81075f9d52621da7114a12362b472e068aea56af66fe090163e720be17deb06a01a123fef9a22edd76ac793e0dcccbb752c3ffe9da0f36b53e6f5c05578b64b6b4c3296ecd56693ffaff88cfbda3c6103a695c5cf690bd3f67b77b1aca1e8c0ecf0ddfd6ec093be4572b7cc071982e1ab6d2898b07517a14151261ff69192c7a7c2feecbade8c619f6bafc35d01de27abf04e58a36787717e5739c898071f4abd3d3040b964d526deadb026acb880aa665b975d39ee08140d96385006951fe36cc653f5f4a49182562ee299863aabd92fa6a35ef822da0a57e91c369a45d9f1e755cccab8677f656c91e930d8bc3f0b23e4f7bd8f83bc9e7b500af3941ad01fdc64a543c6e7a6c4fd902d5cd2d9760982f5f5f2bb95ba27c79f43b545fbb67ebba4c348522583f202a07f1a3872b13f14568b9e6a865cb39bb235740771d5d243dfd9d0ae4ec635070908ae99367be1048a845d05685a3fba6f4eb2659b0d8e880afffcac44839b9247b638454ea8cf29349183915b17c30972ca64d23a5939ccc3d3b2ff169e51bce258f6d181ee9b376ef67df7bd6f1915d3e387234878804ac7a7a9e51e29cd1cd984ef999e2f777f49e774009bfcc660f96c7e4f94c0165e492dddc2c6ef5ed6f2e8f99f0686188fbf463697b3558fb811199c31c1429246eaed250d869e14b0e20e0589acb983aadcdf6de21861d299a1225353cbd1ffcccaf2c75631be0259ed36ff9df69a74a42e582dcc09c26cd1bc9019ebf2347f4d810dd722caa341bda1db9762bde84dda8c414546df33f73f2ac593fe9b5678fdb497ee86ae948ee71636d4a02f2669aeae2aed2d967a6c698c4c0bc77952b63bc539f3bf42d5edc03c602c45db634901d6b43947de0499d9e59010065165b306b541c2d8a4bacc4418426e7a0e9563b8cec2347082a244ac710bb68b7fb1e5c555d288f3c61e195ff8174b3b80f6358374ed4f3d9e1ab1be5988b814a2bd96c28d64322fb82f99acf64db7ca79a8562df9f0258118068184f3c3320808a753a685d0bb940076d23db9f0aabdfb3fba728fc49ed60b1ccf08d51b14eba7cde46d18e7351792661ad92c86a52ac33aa09fe7986f61bb4d76a0d2e984f7eb5b3f8dcb02cfee4dc38021ec01c19d79c8144c6e4fd1564823b0726965f81b0576393bfc5c4dc5a349eff854282000b5c6024bbca58beffeb52765df305f587bf05c68f31475a2f43208d3dc9e6a5de232444d043a85e5139bd822d041b4630966ce181bf60cb246311c1db11be91c43506215b47576425dfce1c2f4e842daeeb5218164a6d953c62b41add8a69c0a7d84605505aabd8a7851e5c8a37ca632cd45814b7a406bcb742cd560990157d23acfff90c737f791d3461ff74fb18631d2c1109458f98436d30fd12858c0fa231d8a0b546179f509a4a9e373e1f4370df7a8c20324285a7f25c4d187950546dd585ed6a3a9690f0e88e5ec9e99f62ccd61bace95854ed6ba25d3dd77fde60ef5962622d5a61e9e9124e8cee616c8c5eddccd21ba7b1f5a79137ed8da1dde887c6c2e3561b872cc6fa2e324fe694eb2f7b989a762c4af897faef20b2dc841af28b366db41a28b6226e245fb1509d0453b3c07db4caad5371424ce80d0eb8b63fe8e26a798d241c56be3d14feae377d831a7d7e732de3c510aebd7980ba0fef82039249e21d32ac4f3796ac131c218963694ddd72a52752af1427057af25f48164f44d8ec70ee6ec460f515aebf1b9b38260436bd4e2785e23c2db32046d6fca2d1ca19b51acc39926a316068b5b855fad337f4ab7457a3eec3bb18f96e30e487dffc307ea0cde77b31ae4c9371ee316121c147680bf48d03253545cb1d9e09360b4a16628238bc4c5606fb529e3802fc146ab985dadc642192c0dc44017ac287a7cb53dbc172fa68317d0722164176ae24e0316452b26d9e3931563d8348345204249a9efcae0e337b5712ded2f55a8c9949341e0878537c4694d4735cd78779b44dee01a3f5d15397f95dce5696a164d4a40b7a580890aa04023cce2e443db2b9d4d8513caea9ca8e8c4ced8700e589f781eb78171e5e4f53108ae892739bfd92e1bc927c86d903fe4a204466769a77ada4a92b2ce5a32b6c4a26e5ae17fb7e69a516fd6c482bb4326c7610be260b887919e762d25ba31a7ea7322635c702e5084d60c8741049d0c80b1fa04d26fd778fe040dbd14c2ac7674f51537f987f222b1b4d25a354445bbd49a0e8fe8906f35011c84445f59ea595c53632a95421e1ceb2b0a187b5e74ab56349c215ef63af817408b4dca32ddbbe7c8fd600eac6462c887e23949f2573b44f66264667abc83d310bd0ac3d193c64f0ea74656593930bf035a97ecff8d209ea6bdbc8b08da322411ee5195ddab0b045d8ef0fd38d530b0fca36f0392b016cdd173354e18c16eecb5e08ad9e340951ec31d5ee899464865ab033d0edc7240358f31bfdd9da3465bbed9a4b9cecec7d48191ff767b72b3a8bd30ef4f09f430f0697845437b7bf60bd3fbe434e6646880b9b5b5932e1f5019bce67adedf8e8bf268af23e58f55e52eda1fd9bcaae8b7f40cf945ff26543c0f30ee34d45583b11c4db1468c7a9fd7e9933c159b12424557aa3286ca7ce095263f43d4a8e7cf4714e80a96325f029bf5a3b71df71f7f458828d8417b849ccd28f44addb7757ab7f2105db38849c95e4f4e7acbf4cb4f20a07943f33b8ef20fe7347087fe84bc31a6f762b287229bfe82a9d90b65a30f56de353c63ad67cd3ae5cd2292d551e511e12fb52544ca9961ca806b533233ad4efa04e8812c9ed1865a3f1045144c83efb62fd1f811ce91e50aaa02bdbce8fd9c95a9ead5dcdaeb9c070040e667c10543fee73881b4165d92891c13938352e0ba728a69f8a73da96e4e8f198f035cddba4a8326629927f8b069139308361ea2b0f911e245ecd132af7bf8c06dad10f9c749ac77a973d416f8d523355bc9a7670d7ac0cf921affbd5cd4b4f08ef7c89c6c640a61ac6258ca1b2c01c62119a5e6b8acdd89fd5ffe9d4f74dc4029738bdeea567c3ea91d7630e3940c3838a1df8d5681220b63ebacb7824566dc55c57c554b783a4d846635ac8baabc11563c94a1fed9a43e945dfb70be790124fc33d210f54aea733ab0d7c565c541bd173d5e4ec0e8492b5f39539bfda06be46ec423b32d547358a782fcf019e603c297276de2f3dd2a2ca7f4fdca8dbc22b0b3da14977ca88d8c27a2ec8d33f4f5b2cfe611803c8cd34fb300d10d88a6bbfb26b2a7d08546ac0be77bb1d0eed6645f52aad9920f3e5330f7921212724ab0c5a52ffb9b5ca8da3dbd4c3ca77f27610b1adb50d2b7e30ef6431fa16c944c24d32552f6f22586ab6a3d26cf1c1138548668e68e53cf6bb72e258ce85263b597d22b62d01000ee5e7feeaad0825dd23da9f177e5551ecd688a2450ca289288c3caf8e9529a4a35cb55cd7d9b68551d806df1a27cdfd699ccbd2843cd0d2d26337d918bb66f3344fe1d87ce7896ba072a4171f4f0ce78cb7e7c9f454938c85d7cbbe4e3a6b367d870eab55ff4173f104c57058ec340affcb48a77074fe1ac238fc4e632fd09142847c7f1c448df513b377b7c3d3070f4a2fa333db70bf7bb3db43be0c9d91524aad4f1461037d9636f4a7c54cb754df23d6fb4e04b28c64e7ca0100d05725dd9b54168c4a83e37b73cffee273203d556d02621cd0a940dcb70fc59840a0ec36d3f289cea70594eec042a1940544c258227d581fa16540109eecfcf000d07bb0b44631d404f27647c4efe4300708ba0167a64a409a13836c4b20d4fd912facc35163476960925900e2a3bf6997a5cf637dd009cc3aeb60009ec0a57029e53b4337477ece57781d1c03c6693400cc8a3e9689d353658ab0bf1e5458af1447f57a1ef4ff57928da9518dcce22eece6b283bac3688ad084c6c6490d5221da4ef8b4a9c634845064f23f6fe533c24791297947b386741f39c75ac0d8d4d4d40b04cff00fcf9e3d5d5749ef13b5b9ff8a1559f41afc7744c123f82c1b0d11d683d678edfbd116c0440531086dd633eaa05af32ee6ecf23ab10b3916f931ae62de21e2adec221fd1c2444d91b243356dec6c375bc110e72766f5fd22ff5259464be1c84eb57c2138e5feccca35b6d9042a4e1b95c60037f337508a0c22b6971024222011d862f94c003dd19325fdb7bbc38f148d7298c8f20a98249c53f68d9128ea07397653e995d331e2f0b03bf8d39c223ea55b9296b04c67cf42633c1a31e9682d697f837b3b3ac0ede0460c55b615ebd36041895d632dc649ef2c82a132567233e2299e3e3eefb45ce8e13c1d597836f705d4503f04dae76fdf71b2c399d3c7cb414db962c6960c39657afe6210a62fcf0f778c53f0c36f094290a1d3aa5c8f325ae658dfe6000e2cfd428e26cec4cd91e7dca582853232af86866f343306eac846ab4f565520cc008742ccdaf962a1797881487d304e37c81b9f8de5f1a2b7a3998b93f0cb1e3d64127838675f556b03e02536bf4b117bd1d52d9ab8673b8e9ca1902f7347fea7cf8793a160646a93d2d230b20c2ccbb18e56d2129fb48c363aa153619fb815b0f55f31dcc5ea991b31d08a9170999d502faae5558f1c7a226feea649f91da011985a8f3de7fd9f16cebb7892256bb4688b97e5230ac0923144cd5bcb35553383d0286efa29fdc283fa455e3bb4edfdb77f620916b71a8d2e1a6903306b72280d559e42b6964cfa5f747b2df0bdee4e908c0307efce01e6fc335123fdce7a268f52c49add05a431209f1a4cea8f709d2333bbe7cdc60383abe8b63beb455d2e9965123e29c635ba74a204f307713f50f3ba22cf47b3fa632b7ba9b33f8b2b203f54b47ce9f1c4761f3782cf8b76b1091eec8483103e327e63b1136a096e5d44066268975f35cdfc1d129c749594846b1c6c75c2549b319611bfaa7414174fcc7d8a4bcf8ada7c308e049a0c1f3e507570d28b3a260fa28f4d6a6a61cc58b07f0ce2dbd91ac7176f091add376337e8a72dbefd17cfdc885c397acaebe47b20e6140d33d457a89b8a19b3cff0450ee52d9fff86b996725a083e33970d129e37228933e20e60ac43a0e30cb7291c36ee98e9a9941c9bbbcc64832160ee4fec4a076fc2f2d9a785eaadad2c2e743f40284cf3f568e7e33cf5245946bd94384ddc332c11b71ed39ea376c7555cfba176542a229b2ab84fb4acec9b44c54b5dcd4ce4cec8d427e97e2b69688acea8c5db9f9572a51358b46f65622c794538099ba4d4d30d7844ac60cdf1e17886b1f88deb313536526f2d5b7a6a7b9bc2f6f50001dd16061594d4a318a651bf490dee8765f8c8443e3334d6e6f50cabcac01b884c5cf8a84e611db8efde51917fd81ed55b9369f060e59a92047eb28b5be0fd2887a5ff2caf4cc9e264d47c0b3af9c49cb38f89bd5c6f9ed8f827b0554ead339ee31cbfe359f995ebeb0898e1b10237e5c4a0a06359360eda87d55c94638aa65bcc2b5d0cf033d22964f1660d650b831567b04b4f293f9cb1abdbdd5a9ede003d4b728bea136eba9a0972fbb26d857fbbf58d66bf37f617cedf06372035e88ebc71214215e3d60bb4d615caea20c88013207c525cc9c538592115adaec9d9c6dffa1342ea58e68234897d4c0b21b089d9d3582c1142a8b4b8eec6ae05570c5a5cd13ab1792933e80634e28f59b68faebdd075d120b1c5c3327152a1dace08ef3af8d8bdd9bcba229100dc8c7fd93b49c29cbda5c9a836540ba5dc2839a3fcd5c2d3da9b47e2d077e578c679696486e538f756e062e1fe59a94ac79ef43f9bd554446a2a918efac80f62c007355f5c1a58aa9e970ec46174fab3ade96349c3931b1cc79cf527bae3e01520290b206ecc916f1942101b7a05bd24b08c0879aec08863fc6fc31fd94da69a3dfc48a96d48b37b080b5af5df264ddbf96c900d42ab585e079288403520c5d07274e1ad84a0c3b69113cd5210725e0a42da8334723a7242134445fd5127262603b47f2c1ae70aa48fd67d89a131706f54b5733d58403e10687e819816d3bd4fb231f840c6f303863936d2a109622131ee3cbd854e80ef53f6ed81420012c63158869146a86202fb936cdfcd4d9a7d94d1a718a87325766f7852d9e59574343f517f5b5de9dcb396fc1a239ebfd4d1a5e873cbfa55b7d4ca84c975d24884761627ce4a948a18f5c736e225a6b5c74abe227d7ff050dad74a4c6dd01af86c8a62ed32afa5b0e0131b95b346c3824969d5fa26032731cc853c47cffd031ff40874f714b04ec221dee4190668ba9063509ca79f1ca0bb3dddd87972e97830b61134edc68ce8e977e5b8651e798146a2a0fd228a48a5e2d8fba1bc9bcdafbb2918354dd688b1cf3964dbb2bd9857a1c5b4cb54097774d24bb21dd9c61281e2fe952fe27f1fd3e5fb64c54e2d5263e2123e6d6169aa7a635276605052c8f7abe496856091c3ce53f51914292ca766dad1f54b1d6ef3e0edc17fe139d31d791a3582b6cd359efa3889e02cfbb3b915b974f05c531d7fd150c8a7977b69cad8ee7c49aa35193d7c043202fe25a09716b29fd461e517df20f38ce88471837e9b18a0a72cbcb1cb3fbecb05aea89bd059c3a76bd7344c622ff79cdb64fec5aa0d3e0977652c87f191aab86a47f35f180f653a041fd3a71d97029b783432184c8d3af53d424d819ab93f8bbe6e579e803a381eabf9e9ba618251321d7c204bae148512b264473ac7d2f086682f30a66be671685d7ceb27ea53fc582093e75aef2854f0d13fdaa3c2cd7af328a7360a5311b183575aa3c5d3708ecdfc8989f84944496e30c56f852c9183a0ef185dcead07af87094923cb6071c4ab09e08a7297aa49a584e5249aeb270cf0109e5ea736898264ededc0eb5da68e497b4d8525428ddfe8256769fc4fcf8ab22c5970a384f9415972f804556e9baff95cc329c10f2d2e44f40d556af73fd934816ab3d6bf60cedb454a3f23535986e849242ce941148b31cc6b5995fef59e87297391f6da6272588034be1020a0b8323026d3dc930270556aefc9a828275d2a854cf063b8085d62189e2a7708b2409c26e628d7de6ee801ad90ebfae9e7750bebb291db3b21e38845e8a1d1aee6fae70dd182d120f9f5eb3e51b638cdfbd7c954ae7bbff3b16969b1cef02c6df576d83fe9fc89791c4480614446712b2cce44b8137a84c0ea9cd0b434c67b1543a451e76faaebbbb2f94b5374cec1312813d665eca5c7afd97ad035860746405511c8499177134ea49a52eecaf04b0e0bcc4686bdd3b25eceb3c77ae9ebad6c31b0a172f2148d0e9b8d5518d334a3abeb0381a6dff901fd6b45bec9b77a2f4f52b46fd72c55034321f14e85585078a50c1fa3194b388dcba82881316b906c75ae22533fd0c0f542f822d251bc04aa7eaac180b4d39e8eb07bd849800c144cbb1c0a91775998dd16c2b3658e7ffcc4cbf9c679321724fcb39c781119e69388d5166e6b944f94302df0ec88d5294d649fe679d164b59b31ef2cd17b99dcd07743d4b57f40784f08aa4d558b37b01d5a148008706597d9f617c4e46f0b8843cff414789ad8e396fb3141a57cb6db4145ee69cb9f9774d3945c86ac5d1153c270bd8a34343048b043d626e323f601c02bfe42fb3eba","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3c2320404c57132e42a6c641a7eb4dbb"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
